#!/bin/csh -f
#
# backup: backup my files to another place, using rsync.
#

if ($#argv != 2) then
    echo "backup listfile location"
    echo " where listfile is a file containing a pathname list,"
    echo " and location is a destination name in rsync syntax."
    exit 1
endif

# We need to load the list of filenames into a shell variable.
# Unfortunately some names have spaces, and the usual approach
#      set list=(`cat $listfile:q`)
# does not work.  So I use awk to write a csh script, then source it.
# The gensub() precedes all embedded spaces with \ unless there is already one.
set listfile="$1"
set listcsh="$1".csh
awk '\
BEGIN { print "# generated automatically; do not edit this file"; }\
BEGIN { print "set list=(\\"; }\
      { print " " gensub(/([^\\]) (.)/, "\\1\\\\ \\2", "global") "\\"; }\
END   { print ")"; }'\
$listfile:q > $listcsh

source $listcsh
# now $list is a list of files and directories to backup 

set where="$2"
set resourcefork=""

if ("$where" =~ *:*) then
# remote copy over ssh - which I use for backup to linux
    set ssh="-e ssh"
else
# local copy - which I use for backup to portable disk
    set ssh=""
# unfortunately, the following doesn't work well: the attribute files get
# copied EVERY time.
#    set resourcefork="--extended-attributes"
endif

#set echo
rsync $ssh  --log-format="%f %l" --relative --recursive --compress\
	    --links --perms --times $resourcefork\
	    --delete --delete-excluded \
	    --exclude=.Trash --exclude=.FBC\* --exclude=.DS_Store \
	    --exclude=svn-commit.tmp --exclude=svn-commit.tmp~ --exclude=.svn\
	    --exclude=.CFUserTextEncoding --exclude=$listcsh \
	    $list:q $where:q
